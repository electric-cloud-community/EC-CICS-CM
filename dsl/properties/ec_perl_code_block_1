# Shared Code Block 1
# -------------------

# Fetch input parameters into a hash
my $xpath;
if ( $[/javascript (typeof(myParent.jobStepId) == "undefined") ? "1" : "0"] ) {
    $xpath = $ec->getActualParameters({jobId => $ENV{COMMANDER_JOBID}});
}
else {
    $xpath = $ec->getActualParameters({jobStepId => '$[/javascript myParent.jobStepId]'});
}
my %params;
foreach my $node($xpath->find('//actualParameter')->get_nodelist()) {
    my $paramName = $node-> find('actualParameterName')->string_value();
    my $paramValue = $node-> find('value')->string_value();
    $params{$paramName} = $paramValue;
}

# Do value checking and error reporting on input parameters

my $errorsFound = 0;
my @names = keys %params;
for my $name (@names) {
    # If parameter is optional, allow undefined or empty value    
    if (grep( /^$name$/, @optionalParams)) {
       next if (!(length($params{$name}) > 0));
    }
    
    # If there is a regexp defined for $name in %valid, emit an error if the value doesn't match it
    if (defined $valid{$name}) {
        if ($params{$name} !~ $valid{$name}) {
            $errorsFound++;
            print "ERROR: actual parameter named $name with value '$params{$name}' does not match the regular expression $valid{$name} defining allowed values!\n";
        }
    }
}

# Stop if we found any errors
exit -1 if ($errorsFound);

# Fetch plugin config values using $params{'configurationName'}
my $endpoint = $ec->getProperty("/plugins/EC-CICS-CM/project/ec_plugin_cfgs/$params{'configurationName'}/ccUrl")
                ->findnodes("//value")
                ->string_value();
my $ccVersion = $ec->getProperty("/plugins/EC-CICS-CM/project/ec_plugin_cfgs/$params{'configurationName'}/ccVersion")
                ->findnodes("//value")
                ->string_value();
my $credentialName = $ec->getProperty("/plugins/EC-CICS-CM/project/ec_plugin_cfgs/$params{'configurationName'}/credential")
                        ->findnodes("//value")
                        ->string_value();
my $plugin = $ec->getPlugin("EC-CICS-CM");
my $projectName = $plugin->find("//projectName");
my $fullCredential = $ec->getFullCredential("/projects/$projectName/credentials/$credentialName", {value => "password"});
my $username = $fullCredential->find("//user");
my $password = $fullCredential->find("//password");

#### TODO Handle nonstandard code page 1047 XML escaping of unusual characters

#
# Marshal the input parameters into SOAP::Data
#

# Subroutines for common patterns for using SOAP::Data

# Required parameter
sub SoapData {
    my $name = $_[0];
    if (length($params{$name}) > 0) {
        return SOAP::Data->name($name => $params{$name});
    } else {
        print "ERROR: the value of the required parameter $name was undefined or empty!\n";
        exit -1;
    }
}

# Optional parameter (return value is a list which may be empty)
sub SoapDataOptional {
    return ((length($params{$_[0]}) > 0) ? ( SOAP::Data->name($_[0] => $params{$_[0]}) ) : ( ) );
}

# Convert RestrictionCriteria to XML
# Shared across various List* procedures
sub makeRestrictionCriteria {
    my ($restrictionCriteria) = @_;
    my @RestrictionCriteria;

    if (length($restrictionCriteria) > 0) {

        # First go through and collect all the counts
        my $restrictionCount = 0;
        my %listCount;
        my @lines = split(/$/, $restrictionCriteria); # Split into lines
        foreach my $line (@lines) {
            $listCount{$line} = 0;
            my @parts = split(/\s+/, $line); # Split line on whitespace
            foreach my $part (@parts) {
                my @pieces = split(/\./, $part, 3); # Split at first two .'s into field, operator, and value
                if (@pieces == 3) {
                    $listCount{$line}++;
                }
            else
            {
                print "ERROR: Unable to parse Restriction Criteria near '$part'!\n";
                exit -1;
            }
            }
            if ($listCount{$line} > 0) {
                $restrictionCount++;
            }
        }

        if ($restrictionCount > 0) {

            # Now we have counts, go through again and build the actual output
            push(@RestrictionCriteria, SOAP::Data->name('RestrictionCount' => $restrictionCount));
            foreach my $line (@lines) {
                if ($listCount{$line} > 0) {
                    my @RestrictionElement;
                    push(@RestrictionElement, SOAP::Data->name('ListCount' => $listCount{$line}));
                    my @parts = split(/\s+/, $line); # Split line on whitespace
                    foreach my $part (@parts) {
                        my @pieces = split(/\./, $part, 3); # Split at first two .'s into field, operator, and value
                        if (@pieces == 3) {
                            push(@RestrictionElement, SOAP::Data->name('ListElement' => \SOAP::Data->value(
                                SOAP::Data->name('RestrictionField' => $pieces[0]),
                                SOAP::Data->name('RestrictionOperator' => $pieces[1]),
                                SOAP::Data->name('RestrictionValue' => $pieces[2])
                            )));
                        }
                    }
                    push(@RestrictionCriteria, SOAP::Data->name('RestrictionElement' => \SOAP::Data->value(@RestrictionElement)));
                }
            }
        }
    }
    
    my @result;
    push(@result, SOAP::Data->name('RestrictionCriteria' => \SOAP::Data->value(@RestrictionCriteria)));
    return @result;
}

# Build XML for parameters specified by a list, if they have values, or if they don't, complain unless they're optional
sub getSoapParameters {
    my ($params, %paramsForEvaluate) = @_;
    my @paramsForRequest;
    for my $param (@{$params}) {
        if (length($paramsForEvaluate{$param}) > 0) {
            push(@paramsForRequest, SoapData($param));
        } elsif (!(grep( /^$param$/, @optionalParams))) {
            print "ERROR: the value of the required parameter $param was undefined or empty!\n";
            exit -1;
        }
    }
    return @paramsForRequest;
}

# Chack XML is valid (without a specific DSD)
sub validateXML {
    my ($str) = @_;
    my $parser = XML::LibXML->new;
    $parser->validation(0);
    $parser->parse_string($str);
}

# Convert ObjectCriteria to XML
# Shared across many procedures
sub createObjectCriteria {
    my ($mandatory, $addCConfig, $wrapper, $params, $wrapSingleElement) = @_;
    my %params = %$params;
    my @mandatory = @{$mandatory};

    my @soapParams;
    if($wrapper ne "") {
        @soapParams =  SOAP::Data->name($wrapper => \SOAP::Data->value(
            getSoapParameters(\@mandatory, %params)
        ));
    }
    else {
        @soapParams =  (
           getSoapParameters(\@mandatory, %params)
        );
    }
    my @configValue;
    if($addCConfig eq '1') {
        push(@configValue, SoapData('CConfig'));
    }

    my @ObjectCriteria;
    if (!(length($params{'ObjectCriteria'}) > 0)) {
        if($wrapSingleElement) {
            @ObjectCriteria = SOAP::Data->name('ObjectCriteria' => \SOAP::Data->value(
                SOAP::Data->name('ListCount' => '1'),
                SOAP::Data->name('ListElement' => \SOAP::Data->value(
                    @configValue,
                    @soapParams
                ))
            ));
        }
        else {
            # No ObjectCriteria, so we only have one element, and can omit the <ListCount> and <ListElement>
            @ObjectCriteria = SOAP::Data->name('ObjectCriteria' => \SOAP::Data->value(
                @configValue,
                @soapParams
            ));
        }
    } else {
        my $objectCriteria = $params{'ObjectCriteria'};
        
        validateXML($objectCriteria);
        my @matches = $objectCriteria =~ m/<ListElement>/si;
        my $listCount = 1 + @matches;
        if ($listCount <= 1) {
            print "ERROR: Serialized Object Criteria did not contain any <ListElement> tags!\n";
            exit -1;
        }    
        #### TODO Do further checks on $objectCriteria XML content against $wrapper, $params, $wrapSingleElement
        
        @ObjectCriteria = SOAP::Data->name('ObjectCriteria' => \SOAP::Data->value(
            @configValue,
            SOAP::Data->name('ListCount' => $listCount),
            SOAP::Data->name('ListElement' => \SOAP::Data->value(
                @soapParams
            )),
            SOAP::Data->type('xml' => $objectCriteria)
        ));
    }
    return @ObjectCriteria;
}

# Convert ObjectData to XML
# Shared across Alter, Create*, Update*
sub createObjectData {
    my ($objectData, $xmlValuesAllowed) = @_;
    my @ObjectData;
    if (!(length($objectData) > 0)) { #### TODO Handle case where this can be optional here, and deal with SOAP XML hackery
        print "ERROR: Object Data Name-Value Pairs missing!\n";
        exit -1;
    } else {
        # Build @ObjectData
        my @lines = split(/$/, $objectData); # Split into lines
        foreach my $line (@lines) {
            my @pieces = split(/=/, $line, 2); # Split at first = into name and value
            if (@pieces == 2) {
                if ($xmlValuesAllowed && ($pieces[1] =~ m|^\s*<[A-Za-z]+>.*</[A-Za-z]+>\s*$|)) {
                    push(@ObjectData, SOAP::Data->name($pieces[0] => SOAP::Data->type('xml' => $pieces[1])));
                } else {
                    push(@ObjectData, SOAP::Data->name($pieces[0] => $pieces[1]));
                } 
            } else {
                print "ERROR: Unable to parse Object Data Name-Value Pairs at '$line'!\n";
                exit -1;
            }
        }
    }
    return @ObjectData;
}

