# Shared Code Block 2
# -------------------

# Handle basic authentication
if (length($password)) {
    # This is insecure unless $endpoint starts with 'https://'
    if ($endpoint !~ m|^https://|) { 
        print "WARNING: Sending a password via basic authentication over http:// protocol is insecure (unless you are using a fully trusted network)\n";
    }

    sub SOAP::Transport::HTTP::Client::get_basic_credentials {
        return $username => $password;
    }
}

# Make the SOAP call

my $soap = SOAP::Lite->proxy($endpoint);
$soap->autotype(0); # Don't automatically add parameter type annotations
$soap->readable(1); # Pretty-print the XML
$soap->outputxml(1); # Don't automatically deserialize the returned xml (since it's unhelpfully designed for that)

# print"\$soap object before request:\n"; #### TODO Remove debugging output
# print Dumper($soap);
print"\n\@data objects before request:\n";
print Dumper(@data);
                     
my $xml = $soap->call($ccVersion, @data);

# print"\$xml:\n$xml\n"; #### TODO Remove debugging output

my $deserializer = SOAP::Deserializer->new;
my $som = $deserializer ->deserialize($xml);

# print"\n\$som object after deserialization:\n"; #### TODO Remove debugging output
# print Dumper($som);

# Check for and handle SOAP error response
if ($som->fault) {
    print("ERROR: $som->faultcode from $som->faultactor returned $som->faultstring ($som->faultdetail)\n");
    exit -1;
}

# Check for and handle missing CICS CM return code value
my $result = $som->result;

# print"\$result:\n"; #### TODO Remove debugging output
# print Dumper($result);

if (!defined($result) || !defined($result->{'OUTPUTDATA'}) || !defined($result->{'OUTPUTDATA'}->{'RETURNCODE'})) {
    print("ERROR: Invalid response: cannot locate return code value!\n$xml");
    exit -1;
}
my $returnCode = $result->{'OUTPUTDATA'}->{'RETURNCODE'};
my $reasonCode = $result->{'OUTPUTDATA'}->{'REASONCODE'};

# Return the XML result as a property

# Remove uninteresting wrapper parts of the XML (if possible)
my $upperSoapMethodName = uc($soapMethodName);
# print"\$xml:\n$xml\n"; #### TODO Remove debugging output
# print "<SOAP-ENV:Body>\\s*<$ccVersion>\\s*<$upperSoapMethodName>\\s*<OUTPUTDATA>\n";
if ($xml =~ m!<SOAP-ENV:Body>\s*<$ccVersion>\s*<$upperSoapMethodName>\s*<OUTPUTDATA>\s*(<.*)</OUTPUTDATA>\s*</$upperSoapMethodName>\s*</$ccVersion>\s*</SOAP-ENV:Body>!s) {
    $xml = $1;
    $xml =~ s/\s+$//; # Trim any trailing whitespace (this should be faster than doing it above, since it avoids speculative matching)
    # print"\$xml:\n$xml\n"; #### TODO Remove debugging output
}

my $outputPropertyOrPropertySheet = $params{'outputProperty'};
$ec->setProperty($outputPropertyOrPropertySheet, $xml);

#### TODO Implement optionally parsing the results into a property sheet structure, if $outputPropertyOrPropertySheet exists and is a property sheet -- this will require us to first modify LISTELEMENT (and any other potentially dublicated) tags to add a counter to them

# Check for and handle nonzero CICS CM return code value
# 
# We do this _after_ outputting the XML, in case a Commander error 
# handling step wants to access the return code or reason code

if ($returnCode ne '00000000') {

    # Return code '00000004' with certain reason codes should be treated as warnings rather than errors (or possibly even ignored).
    if ($returnCode eq '00000004') {
        my $conditionCode = substr($reasonCode, 4);
        if ($conditionCode eq  '00AC') {
            if ($soapMethodName eq 'Ready') {
                print "WARNING: Readied a change package that was already ready!\n";
                exit 0;
            }
        }
        #### TODO return code 00000004 with a reason code ending in 0003 indicates that an object was not found
        #### TODO return code 00000004 with a reason code ending in 0004 indicates that no matching objects were found
    }

    print "ERROR: Result with non-zero return code '$returnCode' ans reason code '$reasonCode':\n" . Dumper($result);
    exit -1;
}
