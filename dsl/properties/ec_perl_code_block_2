# Shared Code Block 2
# -------------------

# Handle basic authentication
if (length($password)) {
    # This is insecure unless $endpoint starts with 'https://'
    if ($endpoint !~ m|^https://|) { 
        print "WARNING: Sending a password via basic authentication over http:// protocol is insecure (unless you are using a fully trusted network)\n";
    }

    sub SOAP::Transport::HTTP::Client::get_basic_credentials {
        return $username => $password;
    }
}

# Make the SOAP call

my $soap = SOAP::Lite->proxy($endpoint);
$soap->autotype(0); # Don't automatically add parameter type annotations
$soap->readable(1); # Pretty-print the XML
$soap->outputxml(1); # Don't automatically deserialize the returned xml (since it's unhelpfully designed for that)

my $xml = $soap->call($ccVersion, @data);

my $deserializer = SOAP::Deserializer->new;
my $som = $deserializer ->deserialize($xml);

# Check for and handle SOAP error response
if ($som->fault) {
    print("ERROR: $som->faultcode from $som->faultactor returned $som->faultstring ($som->faultdetail)\n");
    exit -1;
}

# Check for and handle missing CICS CM return code value
my $result = $som->result;

if (!defined($result) || !defined($result->{'OUTPUTDATA'}) || !defined($result->{'OUTPUTDATA'}->{'RETURNCODE'})) {
    print("ERROR: Invalid response: cannot locate return code value!\n$xml");
    exit -1;
}
my $returnCode = $result->{'OUTPUTDATA'}->{'RETURNCODE'};
my $reasonCode = $result->{'OUTPUTDATA'}->{'REASONCODE'};

# Return the XML result as a property

# Remove uninteresting wrapper parts of the XML (if possible)
my $upperSoapMethodName = uc($soapMethodName);
if ($xml =~ m!<SOAP-ENV:Body>\s*<$ccVersion>\s*<$upperSoapMethodName>\s*<OUTPUTDATA>\s*(<.*)</OUTPUTDATA>\s*</$upperSoapMethodName>\s*</$ccVersion>\s*</SOAP-ENV:Body>!s) {
    $xml = $1;
    $xml =~ s/\s+$//; # Trim any trailing whitespace (this should be faster than doing it above, since it avoids speculative matching)
}

# Apply EBCDIC -> ASCII XML decoding.
$xml =~ s/\%([0-9A-F][0-9A-F])/$asciiXml{$1}/egs;

my $outputPropertyOrPropertySheet = $params{'outputProperty'};

# Recursively turn a tree of hashes of arrays as produced by XML::Simple into a nested sest of property
# sheets and properties, adding index values to the name of array enties (which the parser generates
# from repeated child tags -- or potentially repeated ones like LISTELEMENT).
sub walkXMLSimpleTree {
    my ($tree, $path) = @_;
    
    # print '$path = \'' . $path . "'\n"; #### TODO Remove debug output
    # print '$tree = ' . Dumper($tree); #### TODO Remove debug output
    # print 'ref $tree = \'' . (ref $tree) . "'\n"; #### TODO Remove debug output
    
    if (ref $tree eq ref []) {
        # print 'Iterating over array of length ' . scalar(@$tree) . "...\n"; #### TODO Remove debug output
        
        # Iterate over array entries
        for (my $i = 0; $i < length(@{$tree}); $i++) {
            my $newPath = $path . '_' . $i;
            walkXMLSimpleTree(\($tree->[$i]), $newPath);
        }
    } elsif (ref $tree eq ref {}) {
        # Attempt to treate property sheet at $path
        eval {$ec->createProperty($path, {propertyType => 'sheet'})};
        
        # print 'Iterating over hash of size ' . scalar(keys(%$tree)) . "...\n"; #### TODO Remove debug output
        
        # Iterate over hash keys
        foreach my $key (keys(%$tree)) {
	    walkXMLSimpleTree(\($tree->{$key}), $path . '/' . $key);
	}
    } elsif (ref $tree eq 'REF') {
        walkXMLSimpleTree($$tree, $path);
    } else {
        # print 'Creating property with value \'' . $$tree . "'\n"; #### TODO Remove debug output

        # Create or set property at $path with value $$tree
        $ec->setProperty($path, {value => $$tree});
    }
}

# Check if $outputPropertyOrPropertySheet exists and is a property sheet.
eval {($ec->getProperty($outputPropertyOrPropertySheet.'/propertySheetId')->findvalue("//value")->value())};
if ($@) {
   
    # Check if $outputPropertyOrPropertySheet exists
    eval {($ec->getProperty($outputPropertyOrPropertySheet)->findvalue("//value")->value())};
    if ($@) {
        # print $outputPropertyOrPropertySheet . " doesn't exist, creating it...\n"; #### TODO Remove debug output

        $ec->createProperty($outputPropertyOrPropertySheet, $xml);
    } else {    
        # print $outputPropertyOrPropertySheet . " exists as a property, updating its value to XML result...\n"; #### TODO Remove debug output

        $ec->setProperty($outputPropertyOrPropertySheet, $xml);
    }
} else {
    # print $outputPropertyOrPropertySheet . " exists as a property sheet, parsing XML to create nested property sheet result...\n"; #### TODO Remove debug output
    
    $xml = '<OUTPUTDATA>' . $xml . '</OUTPUTDATA>';

    # print '$xml= \'' . $xml. "'\n"; #### TODO Remove debug output

    # If $outputPropertyOrPropertySheet exists and is a property sheet then parse the results into
    # a nested property sheet structure, adding index values to repeats child element names
    my $simple = XML::Simple->new();
    my $tree = $simple->XMLin($xml, forcearray => [ qw(LISTELEMENT) ]);
    
    # print Dumper($tree); #### TODO Remove debug output
    
    walkXMLSimpleTree($tree, $outputPropertyOrPropertySheet);
}

# Check for and handle nonzero CICS CM return code value
# 
# We do this _after_ outputting the XML, in case a Commander error 
# handling step wants to access the return code or reason code

#### TODO Convert reason code to test message

if ($returnCode ne '00000000') {

    # Return code '00000004' with certain reason codes should be treated as warnings rather than errors (or possibly even ignored).
    if ($returnCode eq '00000004') { #### TODO Check for lack of strict mode
        my $conditionCode = substr($reasonCode, 4);
        if ($conditionCode eq  '00AC') { 
            if ($soapMethodName eq 'Ready') {
                print "WARNING: Readied a change package that was already ready!\n";
                exit 0;
            }
        } elsif ($conditionCode eq  '0024') { #### TODO Confirm there is no way to check whether this is due to a "new Group created" or "Group deleted" information message in the MSGUSR output.
            print "WARNING: Reason code 0024 -- probably you created a new group, or deleted an existing group.\n";
            exit 0;
        } elsif ($conditionCode eq  '009D') { #### TODO Confirm there is no way to check whether this is due to a "new Group created" or "Group deleted" information message in the MSGUSR output.
            print "WARNING: Reason code 009D -- probably you created a new group, or deleted an existing group.\n";
            exit 0;
        }
        #### TODO return code 00000004 with a reason code ending in 0003 indicates that an object was not found
        #### TODO return code 00000004 with a reason code ending in 0004 indicates that no matching objects were found
        #### TODO return code 00000004 with a reason code ending in 004D indicates that chnage package was already backed out
        #### TODO return code 00000004 with a reason code ending in 005C indicates that chnage package was already backed out
        #### TODO return code 00000004 with a reason code ending in 0060 or 0064 indicates that nothing was installed
        #### TODO return code 00000004 with a reason code ending in 006A indicates that nothing was newcopied
        #### TODO return code 00000004 with a reason code ending in 0070 or 0072 or 0073 indicates that nothing was discarded
        #### TODO return code 00000004 with a reason code ending in 0086 indicates that nothing was deleted
        #### TODO return code 00000004 with a reason code ending in 0090 indicates that nothing was altered
        #### TODO return code 00000004 with a reason code ending in 0095 indicates that nothing was added
        #### TODO return code 00000004 with a reason code ending in 0098 indicates that nothing was removed
        #### TODO return code 00000004 with a reason code ending in 009C indicates that nothing was renamed
        #### TODO return code 00000004 with a reason code ending in 00AA indicates that APPROVE? or MIGRATE> query returned 0 objects
        #### TODO return code 00000004 with a reason code ending in 00B0 indicates that nothing was imported
        #### TODO return code 00000004 with a reason code ending in 00CD indicates that object was already in the desired state
        #### TODO return code 00000004 with a reason code ending in 00E3 indicates that nothing was found for KILL request
        #### TODO return code 00000004 with a reason code ending in 00E6 indicates that recovery was skipped for delete of non-existent definition
    }

    print "ERROR: Result with non-zero return code '$returnCode' and reason code '$reasonCode':\n" . Dumper($result);
    exit -1;
}
